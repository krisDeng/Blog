<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <title>Kris的博客</title>
    <link rel="stylesheet" href="../../../../css/style.css">
    <link rel="stylesheet" href="../../../../css/gitment.css">
    <link rel="stylesheet" type="text/css" href="//at.alicdn.com/t/font_859455_eaq7v6w8ktj.css">
</head>
<body>
<header class="header">
    <div class="header-inner">
        <div class="header-title">

        </div>
        <nav class="header-nav">
            
            <a href="../../../../index.html" class="header-nav-link">
                首页
            </a>
            

            
            <a href="../../../../archives" class="header-nav-link">
                归档
            </a>
            

            
            <a href="../../../../tags" class="header-nav-link">
                标签
            </a>
            

            
            <a href="/blog/about/" class="header-nav-link">
                关于
            </a>
            
        </nav>
    </div>
</header>
<header class="mobile-header">
    <div class="mobile-nav">
        <div class="mobile-nav-icon">
            <span></span>
            <span></span>
            <span></span>
        </div>
        <div class="mobile-nav-title">
            <a href="../../../../index.html" class="mobile-nav-title-link">kris's Blog</a>
        </div>

    </div>
    <nav class="mobile-menu">
        <ul class="mobile-menu-list">
            <li class="mobile-menu-item">
                <i class="iconfont icon-home"></i>
                <a href="../../../../index.html" class="mobile-nav-link">首页</a>
            </li>
            <li class="mobile-menu-item">
                <i class="iconfont icon-archive"></i>
                <a href="../../../../archives" class="mobile-nav-link">归档</a>
            </li>
            <li class="mobile-menu-item">
                <i class="iconfont icon-tag"></i>
                <a href="../../../../tags" class="mobile-nav-link">标签</a>
            </li>
            <li class="mobile-menu-item">
                <i class="iconfont icon-about"></i>
                <a href="/blog/about/" class="mobile-nav-link">关于</a>
            </li>
        </ul>
    </nav>
</header>
<div class="main">
    <div class="content-inner">
        <div class="posts">
    <article class="post-whole">
        <div class="post-title">
            <h2 class="title">Swift代码规范</h2>
            <div class="post-meta">
                <span class="post-time">2017-04-12</span>
                
                <span class="post-category">
                    
                    <a class="category" href="../../../../categories/Swift/">Swift</a>
                    
                </span>
                
                <span class="post-visit"> 阅读次数：<span id="busuanzi_value_page_pv"></span></span>
            </div>
        </div>
        <div class="post-toc" id="post-toc">
    <strong class="post-toc-title">目录</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-代码格式"><span class="toc-text">1. 代码格式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-命名"><span class="toc-text">2 命名</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-代码风格"><span class="toc-text">3. 代码风格</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-综合"><span class="toc-text">3.1 综合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-访问控制修饰符"><span class="toc-text">3.2 访问控制修饰符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-自定义操作符"><span class="toc-text">3.3 自定义操作符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-Switch-语句-和-枚举"><span class="toc-text">3.4 Switch 语句 和 枚举</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-可选类型"><span class="toc-text">3.5 可选类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-协议"><span class="toc-text">3.6 协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-属性"><span class="toc-text">3.7 属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-8-闭包"><span class="toc-text">3.8 闭包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-9-数组"><span class="toc-text">3.9 数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-10-错误处理"><span class="toc-text">3.10 错误处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-11-使用-guard-语句"><span class="toc-text">3.11 使用 guard 语句</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-文档-注释"><span class="toc-text">4. 文档/注释</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-文档"><span class="toc-text">4.1 文档</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-其他注释原则"><span class="toc-text">4.2 其他注释原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#拓展阅读："><span class="toc-text">拓展阅读：</span></a></li></ol></li></ol>
    <div class="back-to-top" id="back-to-top">
        <a href="javascript:void(0);">回到顶部</a>
    </div>
</div>
        <div class="post-content">
            <h1 id="1-代码格式"><a href="#1-代码格式" class="headerlink" title="1. 代码格式"></a>1. 代码格式</h1><ol>
<li>代码格式</li>
</ol>
<ul>
<li>1.1 使用四个空格进行缩进。</li>
<li>1.2  每行最多160个字符，这样可以避免一行过长。 (Xcode -&gt; Preferences-&gt;Text Editing-&gt; Page guide at column: 设置成160即可)</li>
<li>1.3  确保每个文件结尾都有空白行。</li>
<li>1.4  确保每行都不以空白字符作为结尾 （Xcode -&gt; Preferences -&gt; Text Editing -&gt; Automatically trim trailing whitespace + Including whitespace-only lines).</li>
<li><p>1.5  左大括号不用另起一行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class SomeClass &#123;</span><br><span class="line"> func someMethod() &#123;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>1.6 当在写一个变量类型，一个字典里的主键，一个函数的参数，遵从一个协议，或一个父类，不用在冒号前添加空格，冒号后需添加空格。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 说明</span><br><span class="line">let test:[空格]String = &quot;swift&quot;</span><br><span class="line">// 指定类型</span><br><span class="line">let pirateViewController: PirateViewController</span><br><span class="line"></span><br><span class="line"> // 字典语法(注意这里是向左对齐而不是分号对齐, Xcode换行默认对其方式)</span><br><span class="line">let ninjaDictionary: [String: AnyObject] = [</span><br><span class="line">&quot;fightLikeDairyFarmer&quot;: false,</span><br><span class="line">&quot;disgusting&quot;: true</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">// 声明函数</span><br><span class="line">func myFunction&lt;T, U: SomeProtocol where T.RelatedType == U&gt;(firstArgument: U, secondArgument: T) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调用函数</span><br><span class="line"> someFunction(someArgument: &quot;Kitten&quot;)</span><br><span class="line"></span><br><span class="line">// 父类</span><br><span class="line">class PirateViewController: UIViewController &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 协议</span><br><span class="line"> extension PirateViewController: UITableViewDataSource &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>1.7  要在逗号后面加空格。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let myArray = [1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure>
</li>
<li><p>1.8  二元运算符(+, ==, 或-&gt;)的<code>前后</code>都需要添加空格，左圆括号<code>(</code>后面和右圆括号<code>)</code>前面不需要空格。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> let myValue = 20 + (30 / 2) * 3</span><br><span class="line">if 1 + 1 == 3 &#123;</span><br><span class="line"> fatalError(&quot;The universe is broken.&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func pancake() -&gt; Pancake &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>1.9  遵守Xcode内置的缩进格式( 如果已经遵守，按下<code>CTRL-i</code> 组合键文件格式没有变化)。当声明的一个函数需要跨多行时，推荐使用Xcode默认的格式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Xcode针对跨多行函数声明缩进(参数左对齐，不是冒号对齐)</span><br><span class="line">func myFunctionWithManyParameters(parameterOne: String,</span><br><span class="line">parameterTwo: String,</span><br><span class="line">parameterThree: String) &#123;</span><br><span class="line"> // Xcode会自动缩进</span><br><span class="line"> print(&quot;\(parameterOne) \(parameterTwo) \(parameterThree)&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Xcode针对多行 if 语句的缩进（Xcode默认换行对齐）</span><br><span class="line">if myFirstVariable &gt; (mySecondVariable + myThirdVariable)</span><br><span class="line"> &amp;&amp; myFourthVariable == .SomeEnumValue &#123;</span><br><span class="line"></span><br><span class="line"> // Xcode会自动缩进</span><br><span class="line"> print(&quot;Hello, World!&quot;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>1.10  当调用的函数有多个参数时，每一个参数另起一行，并比函数名多一个缩进。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">someFunctionWithManyArguments(</span><br><span class="line">firstArgument: &quot;Hello, I am a string&quot;,</span><br><span class="line">secondArgument: resultFromSomeFunction()</span><br><span class="line">thirdArgument: someOtherLocalVariable)</span><br></pre></td></tr></table></figure>
</li>
<li><p>1.11  当遇到需要处理的数组或字典内容较多需要多行显示时， <code>[</code> 和 <code>]</code> 类似于方法体里的括号， 方法体里的闭包也要做类似处理。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">someFunctionWithABunchOfArguments(</span><br><span class="line">someStringArgument: &quot;hello I am a string&quot;,</span><br><span class="line">someArrayArgument: [</span><br><span class="line">  &quot;dadada daaaa daaaa dadada daaaa daaaa dadada daaaa daaaa&quot;,</span><br><span class="line"> &quot;string one is crazy - what is it thinking?&quot;</span><br><span class="line">  ],</span><br><span class="line">someDictionaryArgument: [</span><br><span class="line">&quot;dictionary key 1&quot;: &quot;some value 1, but also some more text here&quot;,</span><br><span class="line">  &quot;dictionary key 2&quot;: &quot;some value 2&quot;</span><br><span class="line"> ],</span><br><span class="line"> someClosure: &#123; parameter1 in</span><br><span class="line">print(parameter1)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>1.12 应尽量避免出现多行断言，可使用本地变量或其他策略。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> // 推荐</span><br><span class="line"> let firstCondition = x == firstReallyReallyLongPredicateFunction()</span><br><span class="line"> let secondCondition = y == secondReallyReallyLongPredicateFunction()</span><br><span class="line"> let thirdCondition = z == thirdReallyReallyLongPredicateFunction()</span><br><span class="line"> if firstCondition &amp;&amp; secondCondition &amp;&amp; thirdCondition &#123;</span><br><span class="line"> // 你要干什么</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  // 不推荐</span><br><span class="line">  if x == firstReallyReallyLongPredicateFunction()</span><br><span class="line">  &amp;&amp; y == secondReallyReallyLongPredicateFunction()</span><br><span class="line">  &amp;&amp; z == thirdReallyReallyLongPredicateFunction() &#123;</span><br><span class="line">  // 你要干什么</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-命名"><a href="#2-命名" class="headerlink" title="2 命名"></a>2 命名</h1><ul>
<li>2.1  使用帕斯卡拼写法（又名<code>大骆驼</code>拼写法，首字母大写）为<code>类型</code>命名 (如 struct, enum, class, typedef, associatedtype 等)。</li>
<li>2.2  使用<code>小骆驼</code>拼写法 (首字母小写) 为<code>函数</code>，<code>方法</code>，<code>变量</code>，<code>常量</code>，<code>参数</code>等命名。</li>
<li>2.3  首字母缩略词在命名中一般来说都是全部大写，例外的情形是如果首字母缩略词是一个命名的开始部分，而这个命名需要小写字母作为开头，这种情形下首字母缩略词全部小写。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// &quot;HTML&quot; 是变量名的开头, 需要全部小写 &quot;html&quot;(因为变量是小驼峰，开头要小写)</span><br><span class="line">let htmlBodyContent: String = &quot;Hello, World!&quot;</span><br><span class="line"></span><br><span class="line">// 推荐使用 ID 而不是 Id</span><br><span class="line">let profileID: Int = 1</span><br><span class="line"></span><br><span class="line">// 推荐使用 URLFinder 而不是 UrlFinder(因为类型是大驼峰)</span><br><span class="line"> class URLFinder &#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>2.4  使用前缀 <code>k + 大骆驼</code>命名法 为所有非单例的静态常量命名。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class MyClassName &#123;</span><br><span class="line">  // 基元常量使用 k 作为前缀</span><br><span class="line">  static let kSomeConstantHeight: CGFloat = 80.0</span><br><span class="line"></span><br><span class="line">  // 非基元常量也是用 k 作为前缀</span><br><span class="line">  static let kDeleteButtonColor = UIColor.redColor()</span><br><span class="line"></span><br><span class="line">  // 对于单例不要使用k作为前缀</span><br><span class="line">  static let sharedInstance = MyClassName()</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>2.5  命名应该具有描述性 和 清晰的。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 推荐</span><br><span class="line">class RoundAnimatingButton: UIButton &#123; &#125;</span><br><span class="line"></span><br><span class="line">// 不推荐</span><br><span class="line">class CustomButton: UIButton &#123; &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>2.6 不要缩写，简写命名，或用单个字母命名。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> // 推荐</span><br><span class="line"> class RoundAnimatingButton: UIButton &#123;</span><br><span class="line">   let animationDuration: NSTimeInterval</span><br><span class="line">    func startAnimating() &#123;</span><br><span class="line">    let firstSubview = subviews.first</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">// 不推荐</span><br><span class="line">class RoundAnimating: UIButton &#123;</span><br><span class="line">   let aniDur: NSTimeInterval</span><br><span class="line">    func srtAnmating() &#123;</span><br><span class="line">    let v = subviews.first</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>2.7 如果原有命名不能明显表明类型，则属性命名内要包括类型信息。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">// 推荐</span><br><span class="line">class ConnectionTableViewCell: UITableViewCell &#123;</span><br><span class="line">   let personImageView: UIImageView</span><br><span class="line">   let animationDuration: NSTimeInterval</span><br><span class="line">   // 作为属性名的firstName，很明显是字符串类型，所以不用在命名里不用包含String</span><br><span class="line">  let firstName: String</span><br><span class="line"></span><br><span class="line">  // 虽然不推荐, 这里用 Controller 代替 ViewController 也可以。</span><br><span class="line">  let popupController: UIViewController</span><br><span class="line">  let popupViewController: UIViewController</span><br><span class="line"></span><br><span class="line">  // 如果需要使用UIViewController的子类，如TableViewController, CollectionViewController, SplitViewController, 等，需要在命名里标名类型。</span><br><span class="line">  let popupTableViewController: UITableViewController</span><br><span class="line"></span><br><span class="line">  // 当使用outlets时, 确保命名中标注类型。</span><br><span class="line">  @IBOutlet weak var submitButton: UIButton!</span><br><span class="line">  @IBOutlet weak var emailTextField: UITextField!</span><br><span class="line">  @IBOutlet weak var nameLabel: UILabel!</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 不推荐</span><br><span class="line">  class ConnectionTableViewCell: UITableViewCell &#123;</span><br><span class="line">   // 这个不是 UIImage, 不应该以Image 为结尾命名。</span><br><span class="line">   // 建议使用 personImageView</span><br><span class="line">   let personImage: UIImageView</span><br><span class="line"></span><br><span class="line">   // 这个不是String，应该命名为 textLabel</span><br><span class="line">  let text: UILabel</span><br><span class="line"></span><br><span class="line">  // animation 不能清晰表达出时间间隔</span><br><span class="line">  // 建议使用 animationDuration 或 animationTimeInterval</span><br><span class="line">  let animation: NSTimeInterval</span><br><span class="line"></span><br><span class="line">  // transition 不能清晰表达出是String</span><br><span class="line">  // 建议使用 transitionText 或 transitionString</span><br><span class="line">  let transition: String</span><br><span class="line"></span><br><span class="line">  // 这个是ViewController，不是View</span><br><span class="line">  let popupView: UIViewController</span><br><span class="line"></span><br><span class="line">  // 由于不建议使用缩写，这里建议使用 ViewController替换 VC</span><br><span class="line">  let popupVC: UIViewController</span><br><span class="line"></span><br><span class="line">  // 技术上讲这个变量是 UIViewController, 但应该表达出这个变量是TableViewController</span><br><span class="line"> let popupViewController: UITableViewController</span><br><span class="line"></span><br><span class="line">  // 为了保持一致性，建议把类型放到变量的结尾，而不是开始，如submitButton</span><br><span class="line">  @IBOutlet weak var btnSubmit: UIButton!</span><br><span class="line">  @IBOutlet weak var buttonSubmit: UIButton!</span><br><span class="line"></span><br><span class="line">  // 在使用outlets 时，变量名内应包含类型名。</span><br><span class="line">  // 这里建议使用 firstNameLabel</span><br><span class="line">  @IBOutlet weak var firstName: UILabel!</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>2.8 根据苹果接口设计指导文档, 如果协议描述的是协议做的事应该命名为名词(如Collection) ，如果描述的是行为，需添加后缀 able 或 ing (如Equatable 和 ProgressReporting)。 如果上述两者都不能满足需求，可以添加Protocol作为后缀，例子见下面:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 这个协议描述的是协议能做的事，应该命名为名词。</span><br><span class="line">protocol TableViewSectionProvider &#123;</span><br><span class="line"></span><br><span class="line">func rowHeight(atRow row: Int) -&gt; CGFloat &#123;</span><br><span class="line">   var numberOfRows: Int &#123; get &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> // 这个协议表达的是行为, 以able最为后缀</span><br><span class="line"> protocol Loggable &#123;</span><br><span class="line">  func logCurrentState() &#123;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> // 因为已经定义类InputTextView，如果依然需要定义相关协议，可以添加Protocol作为后缀。</span><br><span class="line"> protocol InputTextViewProtocol &#123;</span><br><span class="line"> func sendTrackingEvent()</span><br><span class="line"> func inputText() -&gt; String &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-代码风格"><a href="#3-代码风格" class="headerlink" title="3. 代码风格"></a>3. 代码风格</h1><h2 id="3-1-综合"><a href="#3-1-综合" class="headerlink" title="3.1 综合"></a>3.1 综合</h2><ul>
<li>3.1.1 尽可能的多使用let，少使用var。</li>
<li>3.1.2 当需要遍历一个集合并变形成另一个集合时，推荐使用函数 map, filter 和 reduce。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 推荐</span><br><span class="line">let stringOfInts = [1, 2, 3].flatMap &#123; String($0) &#125;</span><br><span class="line">// [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]</span><br><span class="line"></span><br><span class="line">// 不推荐</span><br><span class="line">var stringOfInts: [String] = []</span><br><span class="line">for integer in [1, 2, 3] &#123;</span><br><span class="line">   stringOfInts.append(String(integer))</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> // 推荐</span><br><span class="line"> let evenNumbers = [4, 8, 15, 16, 23, 42].filter &#123; $0 % 2 == 0 &#125;</span><br><span class="line"> // [4, 8, 16, 42]</span><br><span class="line"></span><br><span class="line"> // 不推荐</span><br><span class="line"> var evenNumbers: [Int] = []</span><br><span class="line"> for integer in [4, 8, 15, 16, 23, 42] &#123;</span><br><span class="line"> if integer % 2 == 0 &#123;</span><br><span class="line">  evenNumbers(integer)</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>3.1.3 如果变量类型可以依靠<code>推断</code>得出，不建议声明变量时指明<code>类型</code>。</li>
<li>3.1.4 如果一个函数有多个返回值，推荐使用 <code>元组</code> 而不是 <code>inout</code> 参数， 如果你见到一个元组多次，建议使用<code>typealias</code> ，而如果返回的元组有三个或多于三个以上的元素，建议使用<code>结构体</code>或<code>类</code>。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func pirateName() -&gt; (firstName: String, lastName: String) &#123;</span><br><span class="line">   return (&quot;Guybrush&quot;, &quot;Threepwood&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let name = pirateName()</span><br><span class="line">let firstName = name.firstName</span><br><span class="line">let lastName = name.lastName</span><br></pre></td></tr></table></figure>
<ul>
<li>3.1.5 当使用委托和协议时，请注意避免出现循环引用，基本上是在定义属性的时候使用 <code>weak</code> 修饰。</li>
<li>3.1.6 在闭包里使用 self 的时候要注意出现循环引用，使用捕获列表可以避免这一点。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">myFunctionWithClosure() &#123; [weak self] (error) -&gt; Void in</span><br><span class="line">  // 方案 1</span><br><span class="line">  self?.doSomething()</span><br><span class="line"></span><br><span class="line">  // 或方案 2</span><br><span class="line">  guard let strongSelf = self else &#123;</span><br><span class="line">   return</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   strongSelf.doSomething() &#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>3.1.7 Switch 模块中不用显式使用break。</li>
<li>3.1.8 断言流程控制的时候不要使用小括号。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 推荐</span><br><span class="line">if x == y &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 不推荐</span><br><span class="line">if (x == y) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>3.1.9 在写<code>枚举</code>类型的时候，尽量简写。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 推荐</span><br><span class="line">imageView.setImageWithURL(url, type: .person)</span><br><span class="line">// 不推荐</span><br><span class="line">imageView.setImageWithURL(url, type: AsyncImageView.Type.person)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>3.1.10 在使用<code>类方法</code>的时候不用简写，因为类方法不如 枚举 类型一样，可以根据轻易地推导出上下文。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 推荐</span><br><span class="line">imageView.backgroundColor = UIColor.whiteColor()</span><br><span class="line">// 不推荐</span><br><span class="line">imageView.backgroundColor = .whiteColor()</span><br></pre></td></tr></table></figure>
</li>
<li><p>3.1.11 不建议使用用self.修饰除非需要。</p>
</li>
<li>3.1.12 在新写一个方法的时候，需要衡量这个方法是否将来会被重写，如果不是，请用 <code>final</code> 关键词修饰，这样阻止方法被重写。一般来说，final 方法可以优化编译速度，在合适的时候可以大胆使用它。但需要注意的是，在一个公开发布的代码库中使用 final 和本地项目中使用 final 的影响差别很大的。</li>
</ul>
<h2 id="3-2-访问控制修饰符"><a href="#3-2-访问控制修饰符" class="headerlink" title="3.2 访问控制修饰符"></a>3.2 访问控制修饰符</h2><ul>
<li>3.2.1 把<code>访问修饰符</code>放到第一个位置。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> // 推荐</span><br><span class="line">private static let kMyPrivateNumber: Int</span><br><span class="line"></span><br><span class="line">// 不推荐</span><br><span class="line">static private let kMyPrivateNumber: Int</span><br></pre></td></tr></table></figure>
<ul>
<li><p>3.2.2 <code>访问修饰</code>符不应单独另起一行，应和访问修饰符描述的对象保持在同一行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 推荐</span><br><span class="line">public class Pirate &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 不推荐</span><br><span class="line">class Pirate &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>3.2.3 默认的访问控制修饰符是 internal, 如果需要使用internal 可以省略不写。</p>
</li>
<li>3.2.4 当一个变量需要被单元测试 访问时，需要声明为 internal 类型来使用@testable import {ModuleName}。 如果一个变量实际上是private类型，而因为单元测试需要被声明为 internal类型，确定添加合适的<code>注释文档</code>来解释为什么这么做。这里添加注释推荐使用<code>- warning:</code>标记语法。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> /*</span><br><span class="line"> 这个变量是private 名字</span><br><span class="line">    - warning: 定义为 internal 而不是 private 为了 `@testable`.</span><br><span class="line"> */</span><br><span class="line">let pirateName = &quot;LeChuck&quot;</span><br></pre></td></tr></table></figure>
<h2 id="3-3-自定义操作符"><a href="#3-3-自定义操作符" class="headerlink" title="3.3 自定义操作符"></a>3.3 自定义操作符</h2><ul>
<li>不推荐使用自定义操作符，如果需要创建函数来替代。</li>
<li>在重写操作符之前，请慎重考虑是否有充分的理由一定要在全局范围内创建新的操作符，而不是使用其他策略。</li>
<li>你可以重载现有的操作符来支持新的类型(特别是 == )，但是新定义的必须保留操作符的原来含义，比如 == 必须用来测试是否相等并返回布尔值。</li>
</ul>
<h2 id="3-4-Switch-语句-和-枚举"><a href="#3-4-Switch-语句-和-枚举" class="headerlink" title="3.4 Switch 语句 和 枚举"></a>3.4 Switch 语句 和 枚举</h2><ul>
<li>3.4.1 在使用 Switch 语句时，如果选项是有限集合时（已经case完了所有的情况），不要使用default，相反地，把一些不用的选项放到底部，并用 <code>break</code> 关键词 阻止其执行。</li>
<li>3.4.2 因为Swift 中的 switch 选项默认是包含break的， 如果不需要不用使用 break 关键词。</li>
<li>3.4.3  case 语句 应和 switch 语句<code>左对</code>齐，并在default 上面。</li>
<li>3.4.4 当定义的选项有关联值时，确保关联值有恰当的名称，而不只是类型。<code>(如使用 case Hunger(hungerLevel: Int) 而不是 case Hunger(Int))</code>.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">enum Problem &#123;</span><br><span class="line">   case attitude</span><br><span class="line">     case hair</span><br><span class="line">     case hunger(hungerLevel: Int)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> func handleProblem(problem: Problem) &#123;</span><br><span class="line">   // case switch左对齐</span><br><span class="line">   switch problem &#123;</span><br><span class="line">   case .attitude:</span><br><span class="line">     print(&quot;At least I don&apos;t have a hair problem.&quot;)</span><br><span class="line">   case .hair:</span><br><span class="line">     print(&quot;Your barber didn&apos;t know when to stop.&quot;)</span><br><span class="line">   case .hunger(let hungerLevel):</span><br><span class="line">      print(&quot;The hunger level is \(hungerLevel).&quot;)</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>3.4.5 推荐尽可能使用fall through。</li>
<li>3.4.6 如果default 的选项不应该触发，可以抛出错误 或 断言类似的做法。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func handleDigit(digit: Int) throws &#123;</span><br><span class="line"> case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9:</span><br><span class="line">   print(&quot;Yes, \(digit) is a digit!&quot;)</span><br><span class="line"> default:</span><br><span class="line"> throw Error(message: &quot;The given number was not a digit.&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-5-可选类型"><a href="#3-5-可选类型" class="headerlink" title="3.5 可选类型"></a>3.5 可选类型</h2><ul>
<li>3.5.1 唯一使用<code>隐式拆包可选类型</code>（implicitly unwrapped optionals）的场景是结合@IBOutlets；在其他场景使用 <code>非可选类型</code> 和 <code>常规可选类型</code>，即使有的场景你确定有的变量使用的时候永远不会为 nil， 但这样做可以保持一致性和程序更加健壮。</li>
<li>3.5.2 不要使用 <code>as!</code> 或 <code>try!</code>。</li>
<li><p>3.5.3 如果对于一个变量你不打算声明为可选类型，但当需要检查变量值是否为 nil，推荐用当前值和 nil 直接比较，而不推荐使用 if let 语法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 推荐</span><br><span class="line">if someOptional != nil &#123;</span><br><span class="line"> // 你要做什么</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 不推荐</span><br><span class="line">if let _ = someOptional &#123;</span><br><span class="line"> // 你要做什么</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>3.5.4 不要使用 <code>unowned</code>，unowned 和 weak 变量基本上等价，并且都是隐式拆包( unowned 在引用计数上有少许性能优化)，由于不推荐使用隐式拆包，也不推荐使用unowned 变量。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 推荐</span><br><span class="line">weak var parentViewController: UIViewController?</span><br><span class="line"></span><br><span class="line">// 不推荐</span><br><span class="line">weak var parentViewController: UIViewController!</span><br><span class="line">unowned var parentViewController: UIViewController</span><br></pre></td></tr></table></figure>
<ul>
<li>3.5.5  当拆包取值时，使用和被拆包取值<code>变量相同</code>的名称。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">guard let myVariable = myVariable else &#123;</span><br><span class="line">   return</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-6-协议"><a href="#3-6-协议" class="headerlink" title="3.6 协议"></a>3.6 协议</h2><p>在实现协议的时候，有两种方式来组织你的代码:</p>
<ul>
<li>使用 // MARK: 注释来分割协议实现和其他代码。</li>
<li>使用 extension 在 类/结构体已有代码外，但在同一个文件内。</li>
</ul>
<blockquote>
<p>请注意 extension 内的代码不能被子类重写，这也意味着测试很难进行。 如果这是经常发生的情况，为了代码一致性最好统一使用第一种办法。否则使用第二种办法，其可以代码分割更清晰。</p>
</blockquote>
<p>使用而第二种方法的时候，使用 // MARK: 依然可以让代码在 Xcode 可读性更强。</p>
<h2 id="3-7-属性"><a href="#3-7-属性" class="headerlink" title="3.7 属性"></a>3.7 属性</h2><ul>
<li>3.7.1 对于只读属性、计算(Computed)属性, 提供 getter 而不是 get {}。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var computedProperty: String &#123;</span><br><span class="line"> if someBool &#123;</span><br><span class="line">   return &quot;I&apos;m a mighty pirate!&quot;</span><br><span class="line">   &#125;</span><br><span class="line">   return &quot;I&apos;m selling these fine leather jackets.&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>3.7.2 对于willSet/didSet 和 set 中的<code>旧值</code>和<code>新值</code>虽然可以自定义名称，但推荐使用默认标准名称 <code>newValue</code>/<code>oldValue</code>。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var computedProperty: String &#123;</span><br><span class="line"> get &#123;</span><br><span class="line">  if someBool &#123;</span><br><span class="line">    return &quot;I&apos;m a mighty pirate!&quot;</span><br><span class="line">   &#125;</span><br><span class="line">  return &quot;I&apos;m selling these fine leather jackets.&quot;</span><br><span class="line">  &#125;</span><br><span class="line">   set &#123;</span><br><span class="line">   computedProperty = newValue</span><br><span class="line">   &#125;</span><br><span class="line">   willSet &#123;</span><br><span class="line">   print(&quot;will set to \(newValue)&quot;)</span><br><span class="line">   &#125;</span><br><span class="line">   didSet &#123;</span><br><span class="line">   print(&quot;did set from \(oldValue) to \(newValue)&quot;)</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>3.7.3 在创建类<code>常量</code>的时候，使用 static 关键词修饰。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class MyTableViewCell: UITableViewCell &#123;</span><br><span class="line"> static let kReuseIdentifier = String(MyTableViewCell)</span><br><span class="line"> static let kCellHeight: CGFloat = 80.0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>3.7.4 声明<code>单例属性</code>可以通过下面方式进行：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class PirateManager &#123;</span><br><span class="line"> static let sharedInstance = PirateManager()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-8-闭包"><a href="#3-8-闭包" class="headerlink" title="3.8 闭包"></a>3.8 闭包</h2><ul>
<li>3.8.1 如果参数的类型很明显，可以在函数名里<code>省略参数类型</code>, 但明确声明类型也是允许的。 代码的可读性有时候是添加详细的信息，而有时候部分重复，根据你的判断力做出选择吧，但前后要保持一致性。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 省略类型</span><br><span class="line">doSomethingWithClosure() &#123; response in</span><br><span class="line">print(response)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">// 明确指出类型</span><br><span class="line">doSomethingWithClosure() &#123; response: NSURLResponse in</span><br><span class="line"> print(response)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// map 语句使用简写</span><br><span class="line">[1, 2, 3].flatMap &#123; String($0) &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>3.8.2 如果使用<code>捕捉列表</code> 或 有具体的<code>非Void</code>返回类型，参数列表应该在小括号内， 否则小括号可以省略。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> // 因为使用捕捉列表，小括号不能省略。</span><br><span class="line"> doSomethingWithClosure() &#123; [weak self] (response: NSURLResponse) in</span><br><span class="line">  self?.handleResponse(response)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> // 因为返回类型，小括号不能省略。</span><br><span class="line"> doSomethingWithClosure() &#123; (response: NSURLResponse) -&gt; String in</span><br><span class="line"> return String(response)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>3.8.3 如果闭包是变量类型，不需把变量值放在括号中，除非需要，(如变量类型是可选类型Optional?， 或当前闭包在另一个闭包内）。确保闭包里的所有参数放在小括号中，使用<code>()</code>表示没有参数，<code>Void</code>表示不需要返回值。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 不用把(success: Bool) -&gt; Void用()包起来</span><br><span class="line">let completionBlock: (success: Bool) -&gt; Void = &#123;</span><br><span class="line"> print(&quot;Success? \(success)&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let completionBlock: () -&gt; Void = &#123;</span><br><span class="line"> print(&quot;Completed!&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 因为是optional类型，所以把() -&gt; Void用()包起来</span><br><span class="line">let completionBlock: (() -&gt; Void)? = nil</span><br></pre></td></tr></table></figure>
<ul>
<li>3.8.4 尽可能的使用<code>尾随闭包</code>，除非去除参数名后导致闭包的意义不明确（例如，函数有一个成功闭包一个失败闭包参数）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 尾随闭包trailing closure，参数只有一个闭包</span><br><span class="line">doSomething(1.0) &#123; (parameter1) in</span><br><span class="line">print(&quot;Parameter 1 is \(parameter1)&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 不用尾随闭包no trailing closure，两个参数都是闭包</span><br><span class="line">doSomething(1.0, success: &#123; (parameter1) in</span><br><span class="line"> print(&quot;Success with \(parameter1)&quot;)</span><br><span class="line">&#125;, failure: &#123; (parameter1) in</span><br><span class="line"> print(&quot;Failure with \(parameter1)&quot;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="3-9-数组"><a href="#3-9-数组" class="headerlink" title="3.9 数组"></a>3.9 数组</h2><ul>
<li>3.9.1 基本上不要通过下标直接访问数组内容，如果可能使用如 .first 或 .last, 因为这些方法是非强制类型并<code>不会崩溃</code>；推荐尽可能使用 <code>for item in items</code> 而不是 <code>for i in 0..&lt; items.count</code> 遍历数组。 如果需要通过下标访问数组内容，在使用前要做边界检查。</li>
<li>3.9.2 不要使用 <code>+=</code> 或 <code>+</code> 操作符给<code>数组</code>添加新元素，使用性能较好的<code>.append()</code> 或<code>.appendContentsOf()</code>，如果需要声明数组基于其他的数组并保持不可变类型， 使用 <code>let myNewArray = [arr1, arr2].flatten()</code>，而不是<code>let myNewArray = arr1 + arr2</code> 。</li>
</ul>
<h2 id="3-10-错误处理"><a href="#3-10-错误处理" class="headerlink" title="3.10 错误处理"></a>3.10 错误处理</h2><ul>
<li>3.10.1 返回nil<br>假设一个函数 myFunction 返回类型声明为 String，但是总有可能函数会遇到error，有一种解决方案是返回类型声明为 <code>String?</code>, 当遇到错误的时候返回 nil。</li>
</ul>
<p>例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">func readFile(withFilename filename: String) -&gt; String? &#123;</span><br><span class="line"> guard let file = openFile(filename) else &#123;</span><br><span class="line"> return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> let fileContents = file.read()</span><br><span class="line"> file.close()</span><br><span class="line"> return fileContents</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func printSomeFile() &#123;</span><br><span class="line"> let filename = &quot;somefile.txt&quot;</span><br><span class="line"> guard let fileContents = readFile(filename) else &#123;</span><br><span class="line"> print(&quot;不能打开 \(filename).&quot;)</span><br><span class="line"> return</span><br><span class="line"> &#125;</span><br><span class="line"> print(fileContents)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>3.10.2 使用try/catch<br>实际上如果<code>预知失败的原因</code>，我们应该使用Swift 中的 <code>try/catch</code> 。</li>
</ul>
<p>定义 <code>错误对象</code> 结构体如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct Error: ErrorType &#123;</span><br><span class="line"> public let file: StaticString</span><br><span class="line"> public let function: StaticString</span><br><span class="line"> public let line: UInt</span><br><span class="line"> public let message: String</span><br><span class="line"></span><br><span class="line"> public init(message: String, file: StaticString = file, function: StaticString = function, line: UInt = line) &#123;</span><br><span class="line">  self.file = file</span><br><span class="line">  self.function = function</span><br><span class="line">  self.line = line</span><br><span class="line">  self.message = message</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>使用案例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func readFile(withFilename filename: String) throws -&gt; String &#123;</span><br><span class="line">   guard let file = openFile(filename) else &#123;</span><br><span class="line">   throw Error(message: “打不开的文件名称 \(filename).&quot;)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   let fileContents = file.read()</span><br><span class="line">   file.close()</span><br><span class="line">   return fileContents</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  func printSomeFile() &#123;</span><br><span class="line">   do &#123;</span><br><span class="line">   let fileContents = try readFile(filename)</span><br><span class="line">   print(fileContents)</span><br><span class="line">   &#125; catch &#123;</span><br><span class="line">   print(error)</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>其实项目中还是有一些场景更适合声明为<code>可选类型</code>，而不是<code>错误捕捉和处理</code>，比如在获取远端数据过程中遇到错误，nil作为返回结果是合理的，也就是声明返回可选类型比错误处理更合理。</p>
<p>整体上说，如果一个方法有可能失败，并且使用可选类型作为返回类型会导致错误原因湮没，不妨考虑抛出错误。</p>
<h2 id="3-11-使用-guard-语句"><a href="#3-11-使用-guard-语句" class="headerlink" title="3.11 使用 guard 语句"></a>3.11 使用 guard 语句</h2><ul>
<li>3.11.1 总体上，我们推荐使用提前返回的策略，而不是 if 语句的嵌套。使用 guard 语句可以改善代码的可读性。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 推荐</span><br><span class="line">func eatDoughnut(atIndex index: Int) &#123;</span><br><span class="line"> guard index &gt;= 0 &amp;&amp; index &lt; doughnuts else &#123;</span><br><span class="line">   // 如果 index 超出允许范围，提前返回。</span><br><span class="line">  return</span><br><span class="line"> &#125;</span><br><span class="line">let doughnut = doughnuts[index]</span><br><span class="line"> eat(doughnut)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 不推荐</span><br><span class="line">func eatDoughnuts(atIndex index: Int) &#123;</span><br><span class="line"> if index &gt;= 0 &amp;&amp; index &lt; donuts.count &#123;</span><br><span class="line"> let doughnut = doughnuts[index]</span><br><span class="line"> eat(doughnut)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>3.11.2  在解析可选类型时，推荐使用 guard 语句，而不是 if 语句，因为 guard 语句可以<code>减少不必要的嵌套缩进</code>。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 推荐</span><br><span class="line">guard let monkeyIsland = monkeyIsland else &#123;</span><br><span class="line"> return</span><br><span class="line">&#125;</span><br><span class="line">bookVacation(onIsland: monkeyIsland)</span><br><span class="line">bragAboutVacation(onIsland: monkeyIsland)</span><br><span class="line"></span><br><span class="line">// 不推荐</span><br><span class="line">if let monkeyIsland = monkeyIsland &#123;</span><br><span class="line"> bookVacation(onIsland: monkeyIsland)</span><br><span class="line"> bragAboutVacation(onIsland: monkeyIsland)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 禁止</span><br><span class="line">if monkeyIsland == nil &#123;</span><br><span class="line"> return</span><br><span class="line">&#125;</span><br><span class="line">bookVacation(onIsland: monkeyIsland!)</span><br><span class="line">bragAboutVacation(onIsland: monkeyIsland!)</span><br></pre></td></tr></table></figure>
<ul>
<li>3.11.3 当解析可选类型需要决定在 if 语句 和 guard 语句之间做选择时，最重要的判断标准是是否让代码<code>可读性更强</code>，实际项目中会面临更多的情景，如依赖 2 个不同的布尔值，复杂的逻辑语句会涉及多次比较等，大体上说，根据你的判断力让代码保持一致性和更强可读性， 如果你不确定 if 语句 和 guard 语句哪一个可读性更强，建议使用 guard 。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// if 语句更有可读性</span><br><span class="line">if operationFailed &#123;</span><br><span class="line"> return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// guard 语句这里有更好的可读性</span><br><span class="line">guard isSuccessful else &#123;</span><br><span class="line"> return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 双重否定不易被理解 - 不要这么做</span><br><span class="line">guard !operationFailed else &#123;</span><br><span class="line"> return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>3.11.4 如果需要在2个状态间做出选择，建议使用if 语句，而不是使用 guard 语句。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 推荐</span><br><span class="line">if isFriendly &#123;</span><br><span class="line"> print(&quot;你好, 远路来的朋友！&quot;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line"> print(“穷小子，哪儿来的？&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 不推荐</span><br><span class="line">guard isFriendly else &#123;</span><br><span class="line"> print(&quot;穷小子，哪儿来的？&quot;)</span><br><span class="line"> return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(&quot;你好, 远路来的朋友！&quot;)</span><br></pre></td></tr></table></figure>
<ul>
<li>3.11.5 你只应该在在失败情形下退出当前上下文的场景下使用 guard 语句，下面的例子可以解释 if 语句有时候比 guard 语句更合适 – 我们有两个不相关的条件，不应该相互阻塞。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if let monkeyIsland = monkeyIsland &#123;</span><br><span class="line"> bookVacation(onIsland: monkeyIsland)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> if let woodchuck = woodchuck where canChuckWood(woodchuck) &#123;</span><br><span class="line">  woodchuck.chuckWood()</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>3.11.6 我们会经常遇到使用 guard 语句拆包多个可选值，如果所有拆包失败的错误处理都<code>一致</code>可以把拆包组合到一起 (如 return, break, continue,throw 等).</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 组合在一起因为可能立即返回</span><br><span class="line">guard let thingOne = thingOne,</span><br><span class="line"> let thingTwo = thingTwo,</span><br><span class="line"> let thingThree = thingThree else &#123;</span><br><span class="line"> return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用独立的语句 因为每个场景返回不同的错误</span><br><span class="line">guard let thingOne = thingOne else &#123;</span><br><span class="line"> throw Error(message: &quot;Unwrapping thingOne failed.&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">guard let thingTwo = thingTwo else &#123;</span><br><span class="line"> throw Error(message: &quot;Unwrapping thingTwo failed.&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">guard let thingThree = thingThree else &#123;</span><br><span class="line"> throw Error(message: &quot;Unwrapping thingThree failed.&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-文档-注释"><a href="#4-文档-注释" class="headerlink" title="4. 文档/注释"></a>4. 文档/注释</h1><h2 id="4-1-文档"><a href="#4-1-文档" class="headerlink" title="4.1 文档"></a>4.1 文档</h2><p>如果一个函数比 O(1) 复杂度高，你需要考虑为函数添加注释，因为函数签名(方法名和参数列表) 并不是那么的一目了然，这里推荐比较流行的插件 <code>VVDocumenter</code>. 不论出于何种原因，如果有任何奇淫巧计不易理解的代码，都需要添加注释，对于复杂的 类/结构体/枚举/协议/属性 都需要添加注释。所有公开的 函数/类/变量/枚举/协议/属性/常数 也都需要添加<code>文档</code>，特别是 函数声明(包括名称和参数列表) 不是那么清晰的时候。</p>
<p>写文档时，确保参照<a href="https://developer.apple.com/library/content/documentation/Xcode/Reference/xcode_markup_formatting_ref/Attention.html#//apple_ref/doc/uid/TP40016497-CH29-SW1" target="_blank" rel="noopener">苹果文档</a>中提及的标记语法合集。</p>
<p>在注释文档完成后，你应检查格式是否正确。</p>
<p>规则:</p>
<ul>
<li>4.1.1 一行不要超过160个字符 (和代码长度限制雷同).</li>
<li>4.1.2 即使文档注释只有一行，也要使用模块化格式 (<code>/** */</code>).</li>
<li>4.1.3 注释模块中的空行不要使用 * 来占位。</li>
<li>4.1.4 确定使用新的<code>– parameter</code>格式，而不是旧的<code>Use the new -:param:</code>格式，另外注意 <code>parameter</code>是小写的。</li>
<li>4.1.5 如果需要给一个方法的 参数/返回值/抛出异常 添加注释，务必给所有的添加注释，即使会看起来有部分重复，否则注释会看起来不完整，有时候如果只有一个参数值得添加注释，可以在方法注释里重点描述。</li>
</ul>
<h2 id="4-2-其他注释原则"><a href="#4-2-其他注释原则" class="headerlink" title="4.2 其他注释原则"></a>4.2 其他注释原则</h2><ul>
<li>4.2.1  <code>//</code> 后面要保留空格。</li>
<li>4.2.2  注释必须要另起一行。</li>
<li><p>4.2.3  使用注释<code>// MARK: - xoxo</code>时, 下面一行保留为空行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Pirate &#123;</span><br><span class="line"> // MARK: - 实例属性</span><br><span class="line"> private let pirateName: String</span><br><span class="line"></span><br><span class="line"> // MARK: - 初始化</span><br><span class="line"> init() &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="拓展阅读："><a href="#拓展阅读：" class="headerlink" title="拓展阅读："></a>拓展阅读：</h2><p><a href="https://github.com/Artwalk/swift-style-guide/blob/master/README_CN.md" target="_blank" rel="noopener">Github 官方分享的Swift 编码规范</a><br><a href="http://www.jianshu.com/p/240f2e4e80b2" target="_blank" rel="noopener">几个 Swift 代码规范</a></p>
</li>
</ul>

        </div>
        
        <div class="post-tag">
            
            <a class="tag" href="../../../../tags/规范/" title="规范">规范</a>
            
        </div>
        
    </article>
</div>
<div class="paginator">
    
        
            <a class="prev" href="../../21/iOS如何使用TestFlight进行App Beta版测试/">
                <i class="iconfont icon-prev"></i>
                <span class="nav-default">iOS如何使用TestFlight进行App Beta版测试</span>
                <span class="nav-mobile">上一篇</span>
            </a>
        
        
            <a class="next" href="../../02/iOS Runtime详解/">
                <span class="nav-default">Runtime详解</span>
                <span class="nav-mobile">下一篇</span>
                <i class="iconfont icon-next"></i>
            </a>
        
    
</div>
<div id="comment-container"></div>
    </div>
</div>
<footer class="footer-social">
    

    

    

    <div class="footer-copyright">
        <p class="time-line">
            &copy;
            
            
                2017 -
            
            2020
            &nbsp;<i class="iconfont icon-heart"></i>&nbsp;
            <a target="_blank" href="https://github.com/iJinxin">kris</a>
        </p>
        <p class="theme-info">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme -
            <a target="_blank" href="https://github.com/iJinxin/hexo-theme-sky">Sky</a>
        </p>
    </div>
</footer>
</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="../../../../js/index.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
    

</script>
</html>
